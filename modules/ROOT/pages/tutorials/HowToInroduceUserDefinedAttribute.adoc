= How To Introduce a User-Defined Attribute

== Overview

With SIP3 you can search for calls and build metric dashboards based on a set of defined criteria.

For instance, you can find all calls sent though particular SIP trunk, filter them by state and check which of those had problems with setup time, like it's shown on the picture below:

image::CallSetupTroubleshootingByTrunk.png[Troubleshooting Example]

We call each of the criteria above Service Attributes. They are assigned automatically by SIP3 to each call. You can also use those attributes for building metric dashboards:

image::CallSetupStatisticByTrunk.png[Statistic Example]

Service Attributes can help you troubleshoot and address various problems. That however is not enough to cover different traffic profile use cases.

In this tutorial we will define a specific use case, introducing a User-Defined Attribute, and learn how to use it later.

== Use Case

Everyone in the VoIP community knows https://twitter.com/fredposner[Fred Posner] as a great VoIP engeener and very talented baker.

Awhile back Fred introduced a new community-driven service called https://apiban.org[APIBAN]. A platform for sharing and retrieving a list of fraud IP addresses.

APIBAN is integrated with https://apiban.org/doc.html#kamailioex[Kamailio] and https://apiban.org/doc.html#iptablesex[iptables] which makes it possible to automatically update firewall rules and block any fraud attempts.

Unfortunately, as with any other open source platform, APIBAN's data may be compromised. Thus, the need of a verification via another service.
Thanks to the SIP3 architecture design you can have a monitoring set in place that works in front of iptables.
So even if the traffic has been blocked you will still be able detect fraud attempts and whitelist wrongly blocked IP addresses. You will also:

* see statistics of fraud attempts and determine the size of a fraud attack
* analyze SIP messages retrieved from blacklisted IPs
* be able to find a similar fraud attempts pattern in your own traffic from addresses that are not yet added to your blacklist.

Let's see how this works in action!

For the use case we will introduce two User-Defined Attributes: `blocked` as a Boolean and `blocked_addr` as a String.
The first one will let us search for all calls originated from blacklisted IPs while the second one will show us more detailed information per IP.

NOTE: Before you start, make sure you get yourself familiar with the concept of xref:features/UserDefinedFunctions.adoc[User-Defined Functions].

== User-Defined Function

NOTE: The SIP3 team recommends you to use https://www.jetbrains.com/idea[InteliJ IDEA].
Just clone the https://github.com/sip3io/sip3-salto-ce[SIP3 Salto] project, open it in your IDEA and take an advantage of syntax highlight and autocomplete.

As expected, the use case we are going to implement is a bit more complicated.
However, it's enough just to walk though the https://vertx.io/docs/vertx-core/groovy[Vert.x Documentation] to understand what's happening in the code snippet below:

[source,groovy]
----
class ApiBanUdfExample extends AbstractVerticle {                               // <1>

    private final APIBAN_URL = 'https://apiban.org/api/%YOUR_API_KEY%/banned'

    private Set blocked = []

    @Override
    void start() throws Exception {
        vertx.eventBus().localConsumer("sip_message_udf") { event ->            // <2>
            def packet = event.body()

            if (blocked.contains(packet['src_addr'])) {
                packet['attributes']['blocked'] = true
                packet['attributes']['blocked_addr'] = packet['src_addr']
            }

            event.reply(true)
        }

        asyncUpdateBlocked()                                                    // <3>
    }
}
----

<1> Don't be confused that our code doesn't look like a Groovy script from xref:features/UserDefinedFunctions.adoc[User-Defined Functions] document.
This is because every SIP3 User-Defined Function is a verticle which can be written in https://vertx.io/docs/vertx-core/groovy/#_writing_verticles[multiple ways].
We've chosen to extend `AbstractVerticle` class which gives us more context and control on the IDEA level.
<2> This part is a very simple and looks exactly like any Groovy script from xref:features/UserDefinedFunctions.adoc[User-Defined Functions] document.
For the use case, we will analyze packet's `src_addr` attribute. If this attribute is found in the `blocked` list we will assign User-Defined Attributes stated above.
<3> To update the `blocked` list we need to call APIBAN API. The method `asyncUpdateBlocked` is pretty big that's why you will find it below in a separate code snippet.

[source,groovy]
----
private void asyncUpdateBlocked(String controlId) {
    def url = controlId ? "$APIBAN_URL/$controlId" : APIBAN_URL                 // <1>

    WebClient.create(vertx).getAbs(url).send { asr ->                           // <2>
        if (asr.failed()) {
            vertx.setTimer(UPDATE_PERIOD_MIN * 60000) {                         // <3>
                asyncUpdateBlocked()
            }
        }

        def response = asr.result().bodyAsJsonObject()
        def addresses = response.get('ipaddress') as ArrayList

        blocked.addAll(addresses)                                               // <4>

        if (addresses.size() == 250) {
            def id = response.get('ID') as String                               // <5>
            asyncUpdateBlocked(id)
        } else {
            vertx.setTimer(UPDATE_PERIOD_MIN * 60000) {                         // <6>
                asyncUpdateBlocked()
            }
        }
    }
}
----

//TODO: Explain `asyncUpdateBlocked()` method

== Advanced Search

// TODO: Advanced Search

== Metric Dashboard

// TODO: Metric Dashboard
